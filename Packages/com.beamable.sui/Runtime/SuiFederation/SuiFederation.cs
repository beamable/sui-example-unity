using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Beamable.Common;
using Beamable.Common.Api.Inventory;
using Beamable.Microservices.SuiFederation.Endpoints;
using Beamable.Microservices.SuiFederation.Features.Accounts;
using Beamable.Microservices.SuiFederation.Features.Contracts;
using Beamable.Microservices.SuiFederation.Features.ExecWrapper;
using Beamable.Sui.Common;
using Beamable.Server;
using Beamable.Server.Api.RealmConfig;

namespace Beamable.Microservices.SuiFederation
{
    [Microservice("SuiFederation", CustomAutoGeneratedClientPath =
        "Packages/com.beamable.sui/Runtime/Client/Autogenerated/SuiFederationClient")]
    public class SuiFederation : Microservice, IFederatedInventory<SuiCloudIdentity>
    {
        private static bool _initialized;

        [ConfigureServices]
        public static void Configure(IServiceBuilder serviceBuilder)
        {
            var dependencyBuilder = serviceBuilder.Builder;
            dependencyBuilder.AddFeatures();
            dependencyBuilder.AddEndpoints();
        }

        [InitializeServices]
        public static async Task Initialize(IServiceInitializer initializer)
        {
            try
            {
                // Load realm configuration
                var realmConfigService = initializer.GetService<IMicroserviceRealmConfigService>();
                Configuration.RealmConfig = await realmConfigService.GetRealmConfigSettings();

                // Validate configuration
                if (string.IsNullOrEmpty(Configuration.SuiEnvironment))
                {
                    throw new ConfigurationException($"{nameof(Configuration.SuiEnvironment)} is not defined in realm config. Please apply the configuration and restart the service to make it operational.");
                }

                //Compile Sui SDK TypeScript
                ExecCommand.RunSdkCompilation();

                //Load or create realm account
                await initializer.GetService<AccountsService>().GetOrCreateRealmAccount();

                //Load or create default contract
                await initializer.GetService<ContractService>().GetOrCreateDefaultContract();
            }
            catch (Exception ex)
            {
                BeamableLogger.LogException(ex);
                BeamableLogger.LogWarning("Service initialization failed. Please fix the issues before using the service.");
            }
        }

        [ClientCallable]
        public async Promise<string> InitializeContract()
        {
            // Validate configuration
            if (string.IsNullOrEmpty(Configuration.SuiEnvironment))
            {
                throw new ConfigurationException($"{nameof(Configuration.SuiEnvironment)} is not defined in realm config. Please apply the configuration and restart the service to make it operational.");
            }

            var contract = await Provider.GetService<ContractService>()
                .GetOrCreateDefaultContract();
            return contract.PackageId;
        }

        [ClientCallable]
        public async Promise<string> GetRealmAccount()
        {
            var account = await Provider.GetService<AccountsService>()
                .GetOrCreateRealmAccount();
            return account.Address;
        }

        [ClientCallable]
        public async Promise<string> GetContractAddress()
        {
            return await Provider.GetService<GetContractAddressEndpoint>()
                .GetContractAddress();
        }

        public async Promise<FederatedAuthenticationResponse> Authenticate(string token, string challenge, string solution)
        {
            return await Provider.GetService<AuthenticateEndpoint>()
                .Authenticate(token, challenge, solution);
        }

        public async Promise<FederatedInventoryProxyState> GetInventoryState(string id)
        {
            return await Provider.GetService<GetInventoryStateEndpoint>()
                .GetInventoryState(id);
        }

        public async Promise<FederatedInventoryProxyState> StartInventoryTransaction(string id, string transaction, Dictionary<string, long> currencies, List<FederatedItemCreateRequest> newItems, List<FederatedItemDeleteRequest> deleteItems,
            List<FederatedItemUpdateRequest> updateItems)
        {
            return await Provider.GetService<StartInventoryTransactionEndpoint>()
                .StartInventoryTransaction(id, Context.UserId, transaction, currencies, newItems, deleteItems, updateItems);
        }
    }
}